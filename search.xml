<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一起学习HashMap</title>
    <url>/2021/05/16/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>绕树三匝，何枝可依。——曹操《短歌行》</p>
</blockquote>
<h6 id="HashMap是什么？"><a href="#HashMap是什么？" class="headerlink" title="HashMap是什么？"></a>HashMap是什么？</h6><p>HashMap是基于哈希表实现了Map接口的一个类，它不是线程安全的，即不是同步的。是一种存储键值对的集合，它允许null值和null键，它可以根据给定的key通过哈希函数计算得到存储的位置。</p>
<p>HashMap默认初始容量一般是16，默认负载因子是0.75，当散列表中的数目超过容量的75%时，散列表将会重建为原来的两倍，通过包含两个步骤，即重新开辟空间和重新计算散列。</p>
<span id="more"></span>

<p><strong>为什么默认初始容量是16，默认负载因子是0.75？</strong></p>
<p>默认初始容量16更加符合hash算法的均匀分布原则，倘若是其他则会更加容易引起哈希冲突。负载因子是综合考虑了时间与空间成本的良好折中，更高会降低空间成本，但会增加查找开销（包括put和get）。</p>
<h6 id="HashMap的put与get方法"><a href="#HashMap的put与get方法" class="headerlink" title="HashMap的put与get方法"></a><strong>HashMap的put与get方法</strong></h6><p><strong>put</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;<span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用put方法，传入key和value时，该类又调用了putVal方法，并传入相关参数，其中hash(key)方法源码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，hash方法是计算我们传入put方法key的哈希码，若key为null则哈希值为0，否则获取key的哈希码并将它与它无符号右移16位后的值做异或运算（无符号右移：高位用<font color='red'>0</font>补，右移；异或运算：相异为1，相同为0）。即首先需要计算key的哈希值。</p>
<p>putVal的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="meta">@param</span> onlyIfAbsent <span class="keyword">if</span> <span class="keyword">true</span>, don<span class="string">&#x27;t change existing value</span></span><br><span class="line"><span class="string">* @param evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span></span><br><span class="line"><span class="string">               boolean evict) &#123;</span></span><br><span class="line"><span class="string">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span></span><br><span class="line"><span class="string">    // 首先判断tab是否初始化，若没有则先调用resize()进行初始化</span></span><br><span class="line"><span class="string">    if ((tab = table) == null || (n = tab.length) == 0)</span></span><br><span class="line"><span class="string">        n = (tab = resize()).length;</span></span><br><span class="line"><span class="string">    /*若已经初始化，首先将key的哈希码与(n-1)做与运算，得到i值指向已有散列表中的某个对象，</span></span><br><span class="line"><span class="string">    判断该指向是否为空，若为空直接将key对应的value存在这里*/</span></span><br><span class="line"><span class="string">    /*此处i = (n-1) &amp; hash，是基于数据结构之散列函数设计方法除留余数法的改进，</span></span><br><span class="line"><span class="string">      除留余数法是指关键码key mod p 得到散列地址，p是适当正整数，这里是n-1，即散列表长度减一，</span></span><br><span class="line"><span class="string">     （为什么要减一后面再聊），通过这样设计散列函数得到的散列地址更加随机，更加不会引起冲突*/</span></span><br><span class="line"><span class="string">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></span><br><span class="line"><span class="string">        tab[i] = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="string">    else &#123;</span></span><br><span class="line"><span class="string">        Node&lt;K,V&gt; e; K k;</span></span><br><span class="line"><span class="string">        // 判断我要存入的键值对与该散列地址已有的键值对是否相同(先后比较了两个对象key的哈希值和key的地址)，若相同，直接将该键值对赋给我们要插入的键值对</span></span><br><span class="line"><span class="string">        if (p.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="string">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="string">            e = p;</span></span><br><span class="line"><span class="string">        else if (p instanceof TreeNode)  // 判断已存在Hash中p是否为TreeNode类型，若是调用putTreeVal插入数据</span></span><br><span class="line"><span class="string">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span></span><br><span class="line"><span class="string">        else &#123;</span></span><br><span class="line"><span class="string">            // 此时仅剩要插入的与原有的不一样需要插入数据，于是开始查找该位置 链 上的空位置 </span></span><br><span class="line"><span class="string">            for (int binCount = 0; ; ++binCount) &#123;</span></span><br><span class="line"><span class="string">                if ((e = p.next) == null) &#123;</span></span><br><span class="line"><span class="string">                    // 若找到空位置，将我们要插入的键值对存储在这里</span></span><br><span class="line"><span class="string">                    p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="string">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span></span><br><span class="line"><span class="string">                        treeifyBin(tab, hash);// 若链表到了规定阈值，使用红黑树存储</span></span><br><span class="line"><span class="string">                    break;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                // 重复上述判断是否要存入的和已有的相同，若是算已经存储，退出</span></span><br><span class="line"><span class="string">                if (e.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="string">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="string">                    break;</span></span><br><span class="line"><span class="string">                p = e;// 继续查找空位置</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        // 通过以上不断查找后存储，若e != null，说明我们要插入的数据已经存好了，最后更新相应的value</span></span><br><span class="line"><span class="string">        if (e != null) &#123; // existing mapping for key</span></span><br><span class="line"><span class="string">            V oldValue = e.value;</span></span><br><span class="line"><span class="string">            if (!onlyIfAbsent || oldValue == null)</span></span><br><span class="line"><span class="string">                e.value = value;</span></span><br><span class="line"><span class="string">            afterNodeAccess(e);</span></span><br><span class="line"><span class="string">            return oldValue;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    ++modCount; // 记录HashMap内部结构修改次数</span></span><br><span class="line"><span class="string">    // 判断插入后的大小是否超过阈值，若超过需要扩容处理</span></span><br><span class="line"><span class="string">    if (++size &gt; threshold)</span></span><br><span class="line"><span class="string">        resize();</span></span><br><span class="line"><span class="string">    afterNodeInsertion(evict);</span></span><br><span class="line"><span class="string">    return null;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>get</strong></p>
<p>get源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们是通过给出key而获取value值，首先也是与put方法一样获取key的哈希码，然后调用getNode方法获取对应的Node对象，判断对象是否为空，若为空则返回空，否则返回我们所需要的value值。接下来看看getNode方法的源码，瞅瞅它是如何通过key获取到与key对应的node对象的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">/* 首先就是判断node列表是否为空（table是已有的存有node对象的列表），再判断列表长度是否大于0，</span></span><br><span class="line"><span class="comment">    然后通过（(n-1) &amp; hash）（上面有介绍到）获得key对应的散列地址，通过该散列地址得到对应的node，</span></span><br><span class="line"><span class="comment">    判断该node是否为空。 */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* first是指node列表中某个node链表的头节点 */</span></span><br><span class="line">        <span class="comment">/* 首先判断头节点的hash是否是我们要找的hash，然后判断头节点的key是否是我们想要找的key，</span></span><br><span class="line"><span class="comment">        或者另一种情况，key不为空的情况下判断我们给的key和头节点的key内容上是否相等 </span></span><br><span class="line"><span class="comment">        (这里是区别equals和==吗？没有太读懂。。。)*/</span> </span><br><span class="line">        <span class="comment">// 若满足条件直接返回头节点，即可得到想要的value</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">/* 若是没有在头节点找到想要的，则循着链表依次往下找，首先判断头节点的下一节点是否为空 */</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断头节点是否是红黑树的实例，若是则通过数查找，否则通过链表依次查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结与体会</strong></p>
<p>HashMap的key与value是通过“中介”node去存储相应的key和value的，存储方式通过散列函数(n-1) &amp; key，这样得到的地址减少了地址冲突，有益于存储。再有就是对相同额的散列地址是通过链表额的形式存储，通过指针next去加或找相应的node，也存在通过红黑树作为相同散列地址存储方式的（但是我对这个不熟悉，因此没有深入的分析，记住教训，即将学习它）。emmm。。。还有很多。希望自己多多读源码，找到感觉，再接再厉！</p>
<p>第一次读源码，读得很吃力，有很多不足之处，请多多指教！阿里嘎多^_^</p>
<h6 id="HashMap高并发下引起的死锁"><a href="#HashMap高并发下引起的死锁" class="headerlink" title="HashMap高并发下引起的死锁"></a>HashMap高并发下引起的死锁</h6><p>前面有聊到HashMap的默认负载因子是0.75，这是因为HashMap的容量达到这个阈值会增加哈希冲突，于是就有了扩容rehash这个动作。扩容是扩充到原来的两倍，扩充动作是<font color = "red">两步</font>，首先扩充entry数组到原来的两倍，然后再重新hash原来的map到新的entry，<font color = "red" >此时需要重新计算散列地址，因为长度变了</font>。由于HashMap并非线程安全的，于是当重新hash时，便可能会引起线程死锁。</p>
<p>具体来说是：</p>
<p><a href="https://juejin.cn/post/6844903518331994119">请看大佬^_*^</a>，我的理解是当我们重新计算哈希时，由于相同位置的node链表形成了循环链表，当查找该位置的node值为null时，就会不断查找，于是形成了死锁。</p>
<p>对于该死锁，大佬的解决方案是使用另一个集合类ConcurrentHashMap，该类兼顾了线程安全和性能。通过学习<a href="https://juejin.cn/post/6844904121468715021">该文章</a>，我的理解是jdk1.7是在插入时通过该类继承ReentranLock类而使用类方法加锁的方式去对插入的node进行同步控制，而jdk1.8是对代码块使用synchronized关键字进行同步控制。</p>
<p>关于ConcurrentHashMap的深入研究被挂起，等到进一步源码学习^%_*^</p>
]]></content>
      <categories>
        <category>java_extends</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>我就是我</title>
    <url>/2021/05/27/</url>
    <content><![CDATA[<hr>
<h4 id="主要的flag"><a href="#主要的flag" class="headerlink" title="主要的flag"></a>主要的flag</h4><p>MySQL基础——&gt;<a href="https://juejin.cn/post/6959085197644005407">MySQL基础</a>与进阶——&gt;掘金（<a href="https://juejin.cn/user/122766317588637">谦虚的小叮当</a>）</p>
<p>JVM——&gt;G1 GC收集器的学习，性能调优，复习内存模型和回收算法</p>
<p>Spring/SpringMVC    学习（微信武哥学编程）</p>
<p>数据结构——&gt;B树和B+树，红黑树</p>
<p>继续刷剑指offer——&gt;向中等难度进阶</p>
<p>学习Linux简单命令/shell脚本</p>
<p>完善HashMap源码学习</p>
<p>继续StringBuffer/StringBuilder源码学习，深入复习ArrayList/LinkedList学习</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习路线</tag>
        <tag>求实习</tag>
      </tags>
  </entry>
  <entry>
    <title>java引用理解</title>
    <url>/2021/04/05/</url>
    <content><![CDATA[<hr>
<h6 id="强引用（Strong-Reference"><a href="#强引用（Strong-Reference" class="headerlink" title="强引用（Strong Reference)"></a>强引用（Strong Reference)</h6><p>最常见，仅包内可见。其他三种是public，能在程序中直接使用，因此在垃圾回收时会尝试只回收只有弱引用的对象。</p>
<h6 id="软引用-Soft-Reference"><a href="#软引用-Soft-Reference" class="headerlink" title="软引用(Soft Reference)"></a>软引用(Soft Reference)</h6><p>在JVM抛出OOM之前，GC需要根据算法检查决定回收软引用，会尽量让其存活更长的时间。</p>
<h6 id="弱引用-Weak-Reference"><a href="#弱引用-Weak-Reference" class="headerlink" title="弱引用(Weak Reference)"></a>弱引用(Weak Reference)</h6><p>GC会首先回收该类引用对象进行回收，甚至于进行多次GC回收。更加容易、更快被回收。</p>
<h6 id="虚引用-Phantom-Reference"><a href="#虚引用-Phantom-Reference" class="headerlink" title="虚引用(Phantom Reference)"></a>虚引用(Phantom Reference)</h6><p><em>又称为幽灵引用，主要目的是在一个对象所占的内存被实际回收之前得到通知， 从而可以进行一些相关的清理工作。幽灵引用在使用方式上与之前介绍的三种引用类型有很大的不同。首先幽灵引用在创建时必须提供一个引用队列作为参数，其次幽灵引用对象的 get 方法总是返回 null ， 因此无法通过幽灵引用来获取被引用 的对象。</em></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>经典进程同步问题</title>
    <url>/2021/04/05/</url>
    <content><![CDATA[<hr>
<h5 id="一、生产者-消费者问题"><a href="#一、生产者-消费者问题" class="headerlink" title="一、生产者-消费者问题"></a>一、生产者-消费者问题</h5><h6 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h6><p>生产者生产产品到仓库（缓冲区），消费者从缓冲区获取产品，由于进程的异步性，对共享资源（缓冲区）访问是不可控的，因此我们把缓冲区作为临界资源，所以生产者、消费者和临界资源三者是一种互斥的制约关系。同时，消费者也需要等到生产者生产产品才能获取，因此这也是一个同步问题。</p>
<span id="more"></span>

<h6 id="1、使用记录型信号量解决"><a href="#1、使用记录型信号量解决" class="headerlink" title="1、使用记录型信号量解决"></a>1、使用记录型信号量解决</h6><p>记录性信号量主要是在整型信号量的基础上增加了用于记录等待进程的链表。由问题描述知我们需要解决同步和互斥两个问题。因此设置n为临界资源数量，构建数组存储资源，只有n&gt;0才能存入生产的产品，消费者也才能获取产品。使用mutex作为互斥信号量。</p>
<p>代码描述如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int in &#x3D; 0, out &#x3D; 0;</span><br><span class="line">item[n] buffer;</span><br><span class="line">semaphore mutex &#x3D; 1, empty &#x3D; n, full &#x3D; 0;</span><br><span class="line">void producer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        producer anitem nextp;</span><br><span class="line">        ...</span><br><span class="line">        wait(empty);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        buffer[in] &#x3D; nextp;</span><br><span class="line">        in :&#x3D; (in+1)%n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(full);</span><br><span class="line">    &#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        wait(full);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        nextc &#x3D; buffer[out];</span><br><span class="line">        out &#x3D; (out+1)%n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);</span><br><span class="line">    	consumer the item in nextc;</span><br><span class="line">    &#125;Wwhile(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：mutex作为互斥信号量，empty作为临界资源数量，full表示可用产品数量。producer函数中使用signal(full)表示对消费者可用数量的增加，以便消费者的wait(full)可继续运行，以此保证了同步。</p>
<p>注意的是：wait和signal是成对出现的，而mutex初始值为1，以保证互斥访问。并且，同步层是在互斥层“外”的，顺序不能变。</p>
<p><strong>为什么同步层是外层，而互斥层是内层？</strong></p>
<p>现假设互斥层为外层，同步层为内层。当生产者生产产品进入缓冲区，即调用wait(mutex)，此时锁定了临界资源以实现互斥，继续调用wait(empty)，若<strong>empty=0，</strong>那么将引起阻塞，临界资源将不可更改。此时的状态是：producer等着consumer将产品消费(signal(empty))，而consumer等着producer将占着的临界资源释放(即signal(mutex))，于是开始循环等待，形成了死锁。因此必须<strong>保证同步在外层，互斥在内层。</strong></p>
<h6 id="2、使用AND信号量解决"><a href="#2、使用AND信号量解决" class="headerlink" title="2、使用AND信号量解决"></a>2、使用AND信号量解决</h6><p>主要使用AND信号量的特性一次性解决生产者-消费者问题的同步性和互斥行。AND信号量特性是一次性把所有临界资源分配给一个进程（要么拥有全部，要么一个也不能拥有）。即为用Swait(empty, mutex)替代wait(empty)和wait(mutex)，用Ssignal(mutex, full)替代signal(mutex)和signal(full)。consumer中也是如此。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程同步</tag>
      </tags>
  </entry>
  <entry>
    <title>祝福</title>
    <url>/2021/04/05/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="cf28069566f3df120a9e407baea6029d6bda028e179259635663447d6a36d2b2">91a3f98ed694b0f3ce330b314503f44343c7689568d8c817b41aee8231c1b8ac2c45eee1ff1957654ce39fa614aa72d62edddab2026368902dbe118138dbcebcff0e82ae177ee640a70739f9e2e38d5eabb0f899fab79883e0d15f04d7f696d66365aa378616d4471ab6b706ebbb2eff</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您需要一扇门的钥匙。。。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>感想</tag>
      </tags>
  </entry>
</search>
